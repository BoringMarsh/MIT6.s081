1.
a0-a7存函数的参数
a2存立即数13

2.
没有jalr到f或g的指令，说明编译器将两个函数内联处理了
因此，程序没有调用f或g，而是将它们的指令嵌入了程序的指令序列中

3.
调用printf的那一行标明了# 628 <printf>
因此地址为0x628

4.
首先，jalr指令只有两个参数，说明默认rd寄存器为x1。因此ra为基址寄存器
其次，imm = 1528(0x608)，目标地址为0x628
由变址规则得：imm + ra = 0x628，解得ra = 0x20

5.
HE110 World
i = 0x726c64
E110实际上是由十进制的57616转换为十六进制后得到，只与数值有关，与存放方式无关。因此不用改57616

6.
"y="后面输出的是a2寄存器的值
一方面，a0-a7存了函数的参数，而在第二个整型数缺失时，printf已经获取到了两个参数并存入a0和a1，原本第二个参数就应当存入a2，printf时也会读a2的值
另一方面，当第二个整型数缺失后，a2的值没有刷新，在printf语句执行前是不可预知的，因此会输出一个不确定的数
